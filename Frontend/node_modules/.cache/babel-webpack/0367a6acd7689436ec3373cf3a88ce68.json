{"ast":null,"code":"import _defineProperty from \"C:/Users/Hp/Desktop/ExpertFeesFinal/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"C:/Users/Hp/Desktop/ExpertFeesFinal/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/Hp/Desktop/ExpertFeesFinal/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { InjectionToken, Injectable, Inject, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { mergeMap } from 'rxjs/operators';\nimport { from } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport * as ɵngcc0 from '@angular/core';\nvar JWT_OPTIONS = new InjectionToken('JWT_OPTIONS'); // tslint:disable:no-bitwise\n\nvar JwtHelperService = /*#__PURE__*/function () {\n  function JwtHelperService() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, JwtHelperService);\n\n    this.tokenGetter = config && config.tokenGetter || function () {};\n  }\n\n  _createClass(JwtHelperService, [{\n    key: \"urlBase64Decode\",\n    value: function urlBase64Decode(str) {\n      var output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\n      switch (output.length % 4) {\n        case 0:\n          {\n            break;\n          }\n\n        case 2:\n          {\n            output += \"==\";\n            break;\n          }\n\n        case 3:\n          {\n            output += \"=\";\n            break;\n          }\n\n        default:\n          {\n            throw new Error(\"Illegal base64url string!\");\n          }\n      }\n\n      return this.b64DecodeUnicode(output);\n    } // credits for decoder goes to https://github.com/atk\n\n  }, {\n    key: \"b64decode\",\n    value: function b64decode(str) {\n      var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var output = \"\";\n      str = String(str).replace(/=+$/, \"\");\n\n      if (str.length % 4 === 1) {\n        throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n      }\n\n      for ( // initialize result and counters\n      var bc = 0, bs, buffer, idx = 0; // get next character\n      buffer = str.charAt(idx++); // character found in table? initialize bit storage and add its ascii value;\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,\n      // convert the first 8 bits to one ascii character\n      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n        // try to find character in table (0-63, not found => -1)\n        buffer = chars.indexOf(buffer);\n      }\n\n      return output;\n    }\n  }, {\n    key: \"b64DecodeUnicode\",\n    value: function b64DecodeUnicode(str) {\n      return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), function (c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\"));\n    }\n  }, {\n    key: \"decodeToken\",\n    value: function decodeToken() {\n      var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tokenGetter();\n\n      if (!token || token === \"\") {\n        return null;\n      }\n\n      var parts = token.split(\".\");\n\n      if (parts.length !== 3) {\n        throw new Error(\"The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.\");\n      }\n\n      var decoded = this.urlBase64Decode(parts[1]);\n\n      if (!decoded) {\n        throw new Error(\"Cannot decode the token.\");\n      }\n\n      return JSON.parse(decoded);\n    }\n  }, {\n    key: \"getTokenExpirationDate\",\n    value: function getTokenExpirationDate() {\n      var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tokenGetter();\n      var decoded;\n      decoded = this.decodeToken(token);\n\n      if (!decoded || !decoded.hasOwnProperty(\"exp\")) {\n        return null;\n      }\n\n      var date = new Date(0);\n      date.setUTCSeconds(decoded.exp);\n      return date;\n    }\n  }, {\n    key: \"isTokenExpired\",\n    value: function isTokenExpired() {\n      var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tokenGetter();\n      var offsetSeconds = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (!token || token === \"\") {\n        return true;\n      }\n\n      var date = this.getTokenExpirationDate(token);\n      offsetSeconds = offsetSeconds || 0;\n\n      if (date === null) {\n        return false;\n      }\n\n      return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n  }, {\n    key: \"getAuthScheme\",\n    value: function getAuthScheme(authScheme, request) {\n      if (typeof authScheme === \"function\") {\n        return authScheme(request);\n      }\n\n      return authScheme;\n    }\n  }]);\n\n  return JwtHelperService;\n}();\n\nJwtHelperService.ɵfac = function JwtHelperService_Factory(t) {\n  return new (t || JwtHelperService)(ɵngcc0.ɵɵinject(JWT_OPTIONS));\n};\n\nJwtHelperService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: JwtHelperService,\n  factory: JwtHelperService.ɵfac\n});\n\nJwtHelperService.ctorParameters = function () {\n  return [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [JWT_OPTIONS]\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(JwtHelperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [JWT_OPTIONS]\n      }]\n    }];\n  }, null);\n})();\n\nvar JwtInterceptor = /*#__PURE__*/function () {\n  function JwtInterceptor(config, jwtHelper, document) {\n    _classCallCheck(this, JwtInterceptor);\n\n    this.jwtHelper = jwtHelper;\n    this.document = document;\n    this.standardPorts = [\"80\", \"443\"];\n    this.tokenGetter = config.tokenGetter;\n    this.headerName = config.headerName || \"Authorization\";\n    this.authScheme = config.authScheme || config.authScheme === \"\" ? config.authScheme : \"Bearer \";\n    this.allowedDomains = config.allowedDomains || [];\n    this.disallowedRoutes = config.disallowedRoutes || [];\n    this.throwNoTokenError = config.throwNoTokenError || false;\n    this.skipWhenExpired = config.skipWhenExpired;\n  }\n\n  _createClass(JwtInterceptor, [{\n    key: \"isAllowedDomain\",\n    value: function isAllowedDomain(request) {\n      var requestUrl = new URL(request.url, this.document.location.origin); // If the host equals the current window origin,\n      // the domain is allowed by default\n\n      if (requestUrl.host === this.document.location.host) {\n        return true;\n      } // If not the current domain, check the allowed list\n\n\n      var hostName = \"\".concat(requestUrl.hostname).concat(requestUrl.port && !this.standardPorts.includes(requestUrl.port) ? \":\" + requestUrl.port : \"\");\n      return this.allowedDomains.findIndex(function (domain) {\n        return typeof domain === \"string\" ? domain === hostName : domain instanceof RegExp ? domain.test(hostName) : false;\n      }) > -1;\n    }\n  }, {\n    key: \"isDisallowedRoute\",\n    value: function isDisallowedRoute(request) {\n      var _this = this;\n\n      var requestedUrl = new URL(request.url, this.document.location.origin);\n      return this.disallowedRoutes.findIndex(function (route) {\n        if (typeof route === \"string\") {\n          var parsedRoute = new URL(route, _this.document.location.origin);\n          return parsedRoute.hostname === requestedUrl.hostname && parsedRoute.pathname === requestedUrl.pathname;\n        }\n\n        if (route instanceof RegExp) {\n          return route.test(request.url);\n        }\n\n        return false;\n      }) > -1;\n    }\n  }, {\n    key: \"handleInterception\",\n    value: function handleInterception(token, request, next) {\n      var authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n      var tokenIsExpired = false;\n\n      if (!token && this.throwNoTokenError) {\n        throw new Error(\"Could not get token from tokenGetter function.\");\n      }\n\n      if (this.skipWhenExpired) {\n        tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\n      }\n\n      if (token && tokenIsExpired && this.skipWhenExpired) {\n        request = request.clone();\n      } else if (token) {\n        request = request.clone({\n          setHeaders: _defineProperty({}, this.headerName, \"\".concat(authScheme).concat(token))\n        });\n      }\n\n      return next.handle(request);\n    }\n  }, {\n    key: \"intercept\",\n    value: function intercept(request, next) {\n      var _this2 = this;\n\n      if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n        return next.handle(request);\n      }\n\n      var token = this.tokenGetter(request);\n\n      if (token instanceof Promise) {\n        return from(token).pipe(mergeMap(function (asyncToken) {\n          return _this2.handleInterception(asyncToken, request, next);\n        }));\n      } else {\n        return this.handleInterception(token, request, next);\n      }\n    }\n  }]);\n\n  return JwtInterceptor;\n}();\n\nJwtInterceptor.ɵfac = function JwtInterceptor_Factory(t) {\n  return new (t || JwtInterceptor)(ɵngcc0.ɵɵinject(JWT_OPTIONS), ɵngcc0.ɵɵinject(JwtHelperService), ɵngcc0.ɵɵinject(DOCUMENT));\n};\n\nJwtInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: JwtInterceptor,\n  factory: JwtInterceptor.ɵfac\n});\n\nJwtInterceptor.ctorParameters = function () {\n  return [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [JWT_OPTIONS]\n    }]\n  }, {\n    type: JwtHelperService\n  }, {\n    type: Document,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(JwtInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [JWT_OPTIONS]\n      }]\n    }, {\n      type: JwtHelperService\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nvar JwtModule = /*#__PURE__*/function () {\n  function JwtModule(parentModule) {\n    _classCallCheck(this, JwtModule);\n\n    if (parentModule) {\n      throw new Error(\"JwtModule is already loaded. It should only be imported in your application's main module.\");\n    }\n  }\n\n  _createClass(JwtModule, null, [{\n    key: \"forRoot\",\n    value: function forRoot(options) {\n      return {\n        ngModule: JwtModule,\n        providers: [{\n          provide: HTTP_INTERCEPTORS,\n          useClass: JwtInterceptor,\n          multi: true\n        }, options.jwtOptionsProvider || {\n          provide: JWT_OPTIONS,\n          useValue: options.config\n        }, JwtHelperService]\n      };\n    }\n  }]);\n\n  return JwtModule;\n}();\n\nJwtModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: JwtModule\n});\nJwtModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function JwtModule_Factory(t) {\n    return new (t || JwtModule)(ɵngcc0.ɵɵinject(JwtModule, 12));\n  }\n});\n\nJwtModule.ctorParameters = function () {\n  return [{\n    type: JwtModule,\n    decorators: [{\n      type: Optional\n    }, {\n      type: SkipSelf\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(JwtModule, [{\n    type: NgModule\n  }], function () {\n    return [{\n      type: JwtModule,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }];\n  }, null);\n})();\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };","map":{"version":3,"sources":["../../../projects/angular-jwt/src/lib/jwtoptions.token.ts","../../../projects/angular-jwt/src/lib/jwthelper.service.ts","../../../projects/angular-jwt/src/lib/jwt.interceptor.ts","../../../projects/angular-jwt/src/lib/angular-jwt.module.ts","../../../projects/angular-jwt/src/index.ts","../../../projects/angular-jwt/src/auth0-angular-jwt.ts"],"names":[],"mappings":"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","sourcesContent":["import { InjectionToken } from '@angular/core';\n\nexport const JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n","import { HttpRequest } from \"@angular/common/http\";\n// tslint:disable:no-bitwise\n\nimport { Injectable, Inject } from \"@angular/core\";\nimport { JWT_OPTIONS } from \"./jwtoptions.token\";\n\n@Injectable()\nexport class JwtHelperService {\n  tokenGetter: () => string;\n\n  constructor(@Inject(JWT_OPTIONS) config = null) {\n    this.tokenGetter = (config && config.tokenGetter) || function () {};\n  }\n\n  public urlBase64Decode(str: string): string {\n    let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n      case 0: {\n        break;\n      }\n      case 2: {\n        output += \"==\";\n        break;\n      }\n      case 3: {\n        output += \"=\";\n        break;\n      }\n      default: {\n        throw new Error(\"Illegal base64url string!\");\n      }\n    }\n    return this.b64DecodeUnicode(output);\n  }\n\n  // credits for decoder goes to https://github.com/atk\n  private b64decode(str: string): string {\n    const chars =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    let output = \"\";\n\n    str = String(str).replace(/=+$/, \"\");\n\n    if (str.length % 4 === 1) {\n      throw new Error(\n        \"'atob' failed: The string to be decoded is not correctly encoded.\"\n      );\n    }\n\n    for (\n      // initialize result and counters\n      let bc = 0, bs: any, buffer: any, idx = 0;\n      // get next character\n      (buffer = str.charAt(idx++));\n      // character found in table? initialize bit storage and add its ascii value;\n      ~buffer &&\n      ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n      // and if not first of each 4 characters,\n      // convert the first 8 bits to one ascii character\n      bc++ % 4)\n        ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n        : 0\n    ) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    return output;\n  }\n\n  private b64DecodeUnicode(str: any) {\n    return decodeURIComponent(\n      Array.prototype.map\n        .call(this.b64decode(str), (c: any) => {\n          return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join(\"\")\n    );\n  }\n\n  public decodeToken<T = any>(token: string = this.tokenGetter()): T {\n    if (!token || token === \"\") {\n      return null;\n    }\n\n    const parts = token.split(\".\");\n\n    if (parts.length !== 3) {\n      throw new Error(\n        \"The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.\"\n      );\n    }\n\n    const decoded = this.urlBase64Decode(parts[1]);\n    if (!decoded) {\n      throw new Error(\"Cannot decode the token.\");\n    }\n\n    return JSON.parse(decoded);\n  }\n\n  public getTokenExpirationDate(\n    token: string = this.tokenGetter()\n  ): Date | null {\n    let decoded: any;\n    decoded = this.decodeToken(token);\n\n    if (!decoded || !decoded.hasOwnProperty(\"exp\")) {\n      return null;\n    }\n\n    const date = new Date(0);\n    date.setUTCSeconds(decoded.exp);\n\n    return date;\n  }\n\n  public isTokenExpired(\n    token: string = this.tokenGetter(),\n    offsetSeconds?: number\n  ): boolean {\n    if (!token || token === \"\") {\n      return true;\n    }\n    const date = this.getTokenExpirationDate(token);\n    offsetSeconds = offsetSeconds || 0;\n\n    if (date === null) {\n      return false;\n    }\n\n    return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n  }\n\n  public getAuthScheme(\n    authScheme: Function | string | undefined,\n    request: HttpRequest<any>\n  ): string {\n    if (typeof authScheme === \"function\") {\n      return authScheme(request);\n    }\n\n    return authScheme;\n  }\n}\n","import { Injectable, Inject } from \"@angular/core\";\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor,\n} from \"@angular/common/http\";\nimport { DOCUMENT } from \"@angular/common\";\nimport { JwtHelperService } from \"./jwthelper.service\";\nimport { JWT_OPTIONS } from \"./jwtoptions.token\";\n\nimport { mergeMap } from \"rxjs/operators\";\nimport { from, Observable } from \"rxjs\";\n\n@Injectable()\nexport class JwtInterceptor implements HttpInterceptor {\n  tokenGetter: (\n    request?: HttpRequest<any>\n  ) => string | null | Promise<string | null>;\n  headerName: string;\n  authScheme: string | ((request?: HttpRequest<any>) => string);\n  allowedDomains: Array<string | RegExp>;\n  disallowedRoutes: Array<string | RegExp>;\n  throwNoTokenError: boolean;\n  skipWhenExpired: boolean;\n  standardPorts: string[] = [\"80\", \"443\"];\n\n  constructor(\n    @Inject(JWT_OPTIONS) config: any,\n    public jwtHelper: JwtHelperService,\n    @Inject(DOCUMENT) private document: Document\n  ) {\n    this.tokenGetter = config.tokenGetter;\n    this.headerName = config.headerName || \"Authorization\";\n    this.authScheme =\n      config.authScheme || config.authScheme === \"\"\n        ? config.authScheme\n        : \"Bearer \";\n    this.allowedDomains = config.allowedDomains || [];\n    this.disallowedRoutes = config.disallowedRoutes || [];\n    this.throwNoTokenError = config.throwNoTokenError || false;\n    this.skipWhenExpired = config.skipWhenExpired;\n  }\n\n  isAllowedDomain(request: HttpRequest<any>): boolean {\n    const requestUrl: URL = new URL(request.url, this.document.location.origin);\n\n    // If the host equals the current window origin,\n    // the domain is allowed by default\n    if (requestUrl.host === this.document.location.host) {\n      return true;\n    }\n\n    // If not the current domain, check the allowed list\n    const hostName = `${requestUrl.hostname}${\n      requestUrl.port && !this.standardPorts.includes(requestUrl.port)\n        ? \":\" + requestUrl.port\n        : \"\"\n    }`;\n\n    return (\n      this.allowedDomains.findIndex((domain) =>\n        typeof domain === \"string\"\n          ? domain === hostName\n          : domain instanceof RegExp\n          ? domain.test(hostName)\n          : false\n      ) > -1\n    );\n  }\n\n  isDisallowedRoute(request: HttpRequest<any>): boolean {\n    const requestedUrl: URL = new URL(\n      request.url,\n      this.document.location.origin\n    );\n\n    return (\n      this.disallowedRoutes.findIndex((route: string | RegExp) => {\n        if (typeof route === \"string\") {\n          const parsedRoute: URL = new URL(\n            route,\n            this.document.location.origin\n          );\n          return (\n            parsedRoute.hostname === requestedUrl.hostname &&\n            parsedRoute.pathname === requestedUrl.pathname\n          );\n        }\n\n        if (route instanceof RegExp) {\n          return route.test(request.url);\n        }\n\n        return false;\n      }) > -1\n    );\n  }\n\n  handleInterception(\n    token: string | null,\n    request: HttpRequest<any>,\n    next: HttpHandler\n  ) {\n    const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n    let tokenIsExpired = false;\n\n    if (!token && this.throwNoTokenError) {\n      throw new Error(\"Could not get token from tokenGetter function.\");\n    }\n\n    if (this.skipWhenExpired) {\n      tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\n    }\n\n    if (token && tokenIsExpired && this.skipWhenExpired) {\n      request = request.clone();\n    } else if (token) {\n      request = request.clone({\n        setHeaders: {\n          [this.headerName]: `${authScheme}${token}`,\n        },\n      });\n    }\n    return next.handle(request);\n  }\n\n  intercept(\n    request: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n      return next.handle(request);\n    }\n    const token = this.tokenGetter(request);\n\n    if (token instanceof Promise) {\n      return from(token).pipe(\n        mergeMap((asyncToken: string | null) => {\n          return this.handleInterception(asyncToken, request, next);\n        })\n      );\n    } else {\n      return this.handleInterception(token, request, next);\n    }\n  }\n}\n","import {\n  NgModule,\n  ModuleWithProviders,\n  Optional,\n  SkipSelf,\n  Provider,\n} from \"@angular/core\";\nimport { HttpRequest, HTTP_INTERCEPTORS } from \"@angular/common/http\";\nimport { JwtInterceptor } from \"./jwt.interceptor\";\nimport { JWT_OPTIONS } from \"./jwtoptions.token\";\nimport { JwtHelperService } from \"./jwthelper.service\";\n\nexport interface JwtConfig {\n  tokenGetter?: (\n    request?: HttpRequest<any>\n  ) => string | null | Promise<string | null>;\n  headerName?: string;\n  authScheme?: string | ((request?: HttpRequest<any>) => string);\n  allowedDomains?: Array<string | RegExp>;\n  disallowedRoutes?: Array<string | RegExp>;\n  throwNoTokenError?: boolean;\n  skipWhenExpired?: boolean;\n}\n\nexport interface JwtModuleOptions {\n  jwtOptionsProvider?: Provider;\n  config?: JwtConfig;\n}\n\n@NgModule()\nexport class JwtModule {\n  constructor(@Optional() @SkipSelf() parentModule: JwtModule) {\n    if (parentModule) {\n      throw new Error(\n        \"JwtModule is already loaded. It should only be imported in your application's main module.\"\n      );\n    }\n  }\n  static forRoot(options: JwtModuleOptions): ModuleWithProviders<JwtModule> {\n    return {\n      ngModule: JwtModule,\n      providers: [\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: JwtInterceptor,\n          multi: true,\n        },\n        options.jwtOptionsProvider || {\n          provide: JWT_OPTIONS,\n          useValue: options.config,\n        },\n        JwtHelperService,\n      ],\n    };\n  }\n}\n","/*\n * Public API Surface of angular-jwt\n */\n\nexport * from './lib/jwt.interceptor';\nexport * from './lib/jwthelper.service';\nexport * from './lib/jwtoptions.token';\nexport * from './lib/angular-jwt.module';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"]},"metadata":{},"sourceType":"module"}